/**
 * Build script to generate posts manifest for Cloudflare Workers compatibility.
 *
 * This script:
 * 1. Reads all MDX files
 * 2. Compiles them to plain React components (no MDX runtime needed)
 * 3. Generates metadata manifest and component files
 *
 * Run with: bun scripts/generate-posts.ts
 */

import fs from "fs";
import path from "path";
import matter from "gray-matter";
import { compile } from "@mdx-js/mdx";

const CONTENT_DIR = path.join(process.cwd(), "src/content/blog");
const OUTPUT_DIR = path.join(process.cwd(), "src/lib/generated");
const METADATA_FILE = path.join(OUTPUT_DIR, "posts.ts");
const COMPONENTS_DIR = path.join(OUTPUT_DIR, "blog");

interface PostFrontmatter {
  title: string;
  date: string;
  excerpt: string;
  author: string;
  image?: string;
}

interface PostMetadata {
  slug: string;
  title: string;
  date: string;
  excerpt: string;
  authorId: string;
  image?: string;
}

/**
 * Convert slug to PascalCase for component name
 */
function toPascalCase(slug: string): string {
  return slug
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join("");
}

async function generatePosts(): Promise<void> {
  console.log("Generating posts manifest...");

  // Ensure output directories exist
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }
  if (!fs.existsSync(COMPONENTS_DIR)) {
    fs.mkdirSync(COMPONENTS_DIR, { recursive: true });
  }

  // Check if content directory exists
  if (!fs.existsSync(CONTENT_DIR)) {
    console.warn(`Content directory not found: ${CONTENT_DIR}`);
    await writeEmptyManifests();
    return;
  }

  // Read all MDX files
  const fileNames = fs.readdirSync(CONTENT_DIR).filter((f) => f.endsWith(".mdx"));

  if (fileNames.length === 0) {
    console.warn("No MDX files found in content directory");
    await writeEmptyManifests();
    return;
  }

  const posts: PostMetadata[] = [];

  // Compile each MDX file
  for (const fileName of fileNames) {
    const slug = fileName.replace(/\.mdx$/, "");
    const fullPath = path.join(CONTENT_DIR, fileName);
    const fileContents = fs.readFileSync(fullPath, "utf8");
    const matterResult = matter(fileContents);

    const frontmatter = matterResult.data as PostFrontmatter;

    posts.push({
      slug,
      title: frontmatter.title,
      date: frontmatter.date,
      excerpt: frontmatter.excerpt,
      authorId: frontmatter.author,
      image: frontmatter.image,
    });

    // Compile MDX to JavaScript module
    const compiled = await compile(matterResult.content, {
      outputFormat: "program",
      jsx: false, // Use jsxImportSource instead
      jsxImportSource: "react",
      development: false,
      // Don't use MDX provider - compile to standalone components
      providerImportSource: undefined,
    });

    // Add "use client" directive and wrap the export
    const componentCode = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Compiled from src/content/blog/${fileName}
 */

"use client";

${String(compiled)}`;

    const componentPath = path.join(COMPONENTS_DIR, `${slug}.jsx`);
    fs.writeFileSync(componentPath, componentCode, "utf8");
    console.log(`  Compiled: ${slug}.jsx`);
  }

  // Sort by date (newest first)
  posts.sort((a, b) => (a.date < b.date ? 1 : -1));

  // Generate metadata file
  const metadataOutput = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by scripts/generate-posts.ts
 *
 * Post metadata for listing pages.
 */

export interface PostMetadata {
  slug: string;
  title: string;
  date: string;
  excerpt: string;
  authorId: string;
  image?: string;
}

export const posts: PostMetadata[] = ${JSON.stringify(posts, null, 2)};
`;

  fs.writeFileSync(METADATA_FILE, metadataOutput, "utf8");
  console.log(`Generated metadata for ${posts.length} posts to ${METADATA_FILE}`);

  // Generate index file for components
  const slugs = posts.map((p) => p.slug);
  const imports = slugs
    .map((slug) => `import ${toPascalCase(slug)}Post from "./blog/${slug}.jsx";`)
    .join("\n");

  const registryEntries = slugs
    .map((slug) => `  "${slug}": ${toPascalCase(slug)}Post,`)
    .join("\n");

  const indexOutput = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by scripts/generate-posts.ts
 *
 * Registry of pre-compiled blog post components.
 */

import type { ComponentType } from "react";

${imports}

const postComponents: Record<string, ComponentType> = {
${registryEntries}
};

export function getPostComponent(slug: string): ComponentType | null {
  return postComponents[slug] ?? null;
}

export function postExists(slug: string): boolean {
  return slug in postComponents;
}

export const availableSlugs = ${JSON.stringify(slugs)} as const;
export type PostSlug = (typeof availableSlugs)[number];
`;

  fs.writeFileSync(path.join(OUTPUT_DIR, "post-components.tsx"), indexOutput, "utf8");
  console.log("Generated component registry");
}

async function writeEmptyManifests(): Promise<void> {
  const metadataOutput = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by scripts/generate-posts.ts
 */

export interface PostMetadata {
  slug: string;
  title: string;
  date: string;
  excerpt: string;
  authorId: string;
  image?: string;
}

export const posts: PostMetadata[] = [];
`;

  const indexOutput = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by scripts/generate-posts.ts
 */

import type { ComponentType } from "react";

const postComponents: Record<string, ComponentType> = {};

export function getPostComponent(slug: string): ComponentType | null {
  return postComponents[slug] ?? null;
}

export function postExists(slug: string): boolean {
  return slug in postComponents;
}

export const availableSlugs = [] as const;
export type PostSlug = never;
`;

  fs.writeFileSync(METADATA_FILE, metadataOutput, "utf8");
  fs.writeFileSync(path.join(OUTPUT_DIR, "post-components.tsx"), indexOutput, "utf8");
  console.log("Generated empty manifests");
}

generatePosts().catch(console.error);
